---
title: "Tooling update"
author: "Slides: Logan Brooks, Daniel McDonald, Ryan Tibshirani"
#
# NOTE this link may be required here by upstream GPL-3 slides
date: 2022-12-13 <br /> <small> <https://github.com/brookslogan/tooling-slides-for-modelers> </small>
#
output:
  revealjs::revealjs_presentation:
    theme: night
    highlight: zenburn
    # Nicer, but larger:
    #
    self_contained: false
    reveal_plugins: ["notes","search","menu"]
    #
    # Self-contained html:
    # self_contained: true
---

<!-- Show & update continuously with
`xaringan::inf_mr("midas-demo-slides.Rmd")`.
-->

<!-- Add scroll bars within slides: -->
```{css, echo=FALSE}
.slide {
    height: 750px;
    overflow-y: auto !important;
}
```

<!-- Place plots on a separate second-lever slide from plotting code,
     repeating the most recent second-level slide title: -->
```{r, include=FALSE}
# knitr::knit_hooks$restore("text") # encounters error looking up default
default_text_hook = knitr::knit_hooks$get("text")
previous_l2_heading = NULL
knitr::knit_hooks$set(text = function(x) {
  previous_l2_heading <<- stringi::stri_match_last_regex(x, pattern="\n##.*\n")
  default_text_hook(x)
})
# knitr::knit_hooks$restore("plot") # encounters error looking up default
default_plot_hook = knitr::knit_hooks$get("plot")
knitr::knit_hooks$set(plot = function(x, options) {
  if (identical(knitr::opts_current$get("echo"), FALSE)) {
    default_plot_hook(x, options)
  } else {
    paste0(previous_l2_heading, default_plot_hook(x, options))
  }
})
```

# TODO package author slide & working group background

# {data-background-image=`r xfun::base64_uri("resources/ToolingOverview.png")`}

# `{epiprocess}`

<https://cmu-delphi.github.io/epiprocess>

## Toy `epi_df` (included in {`epiprocess`})

Scroll for full attribution, license:
```{r, echo=FALSE, results="asis"}
withr::with_options(
  code={
    print(help("jhu_csse_daily_subset", package="epiprocess", help_type="text"))
  },
  list(pager=function(files, header, title, delete.file) {
    on.exit({
      unlink(files)
    })
    cat(paste(c("<pre>",purrr::reduce(purrr::map(files, function(file) {
      # gsub("</?u>","_",gsub("</u>( *)<u>","\\1",
      gsub("_\b(.)", "<u>\\1</u>", readLines(file))
      # ))
    }), function(x, y) c(x,"\n\n\n",y)), "</pre>"), collapse="\n"))
  })
)
```

## Toy `epi_archive` (included in {`epiprocess`})

```{r, echo=FALSE, results="asis"}
withr::with_options(
  code={
    print(help("archive_cases_dv_subset", package="epiprocess", help_type="text"))
  },
  list(pager=function(files, header, title, delete.file) {
    on.exit({
      unlink(files)
    })
    cat(paste(c("<pre>",purrr::reduce(purrr::map(files, function(file) {
      # gsub("</?u>","_",gsub("</u>( *)<u>","\\1",
      gsub("_\b(.)", "<u>\\1</u>", readLines(file))
      # ))
    }), function(x, y) c(x,"\n\n\n",y)), "</pre>"), collapse="\n"))
  })
)
```

## `epiprocess::epi_df`

Snapshot of an epi surveillance data set; a specialized data frame.

```{r}
library(epiprocess)
library(dplyr)
library(tidyr)
library(tibble)
library(purrr)
library(ggplot2)

jhu_csse_daily_subset
```

::: notes
- Some methods, like `epi_cor` and `epi_slide` (next), operate on `epi_df`s, while others produce them.
:::

## `epiprocess::growth_rate`

<!-- FIXME discuss completion approaches in epidatr material -->

Prepared from `jhu_csse_daily_subset`
```{r, message=FALSE, warning=FALSE}
# vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
# Note that the `jhu_csse_daily_subset` object already contains regularly-spaced
# time values, and the same time values for every geo value, so it doesn't
# require preprocessing via `complete`.
jhu_csse_daily_subset %>%
  group_by(geo_value) %>%
  mutate(
    cases_gr1 = growth_rate(time_value, cases, method = "rel_change", h=14L),
    cases_gr2 = growth_rate(time_value, cases, method = "linear_reg", h=14L)
  ) %>%
  ungroup() %>%
  # Don't include partial window calculations or extreme Mar 2020 growth rates
  # from near-0 cases:
  mutate(include_gr =
           time_value >= min(time_value) + 13L & time_value <= max(time_value) - 14L &
           time_value >= as.Date("2020-04-01"),
         across(c(cases_gr1, cases_gr2), ~ magrittr::inset(.x, !include_gr, NA)),
         include_gr = NULL) %>%
# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  # -------------------------------
  # ---------- plotting: ----------
  # -------------------------------
  filter(geo_value == "ca") %>%
  pivot_longer(c(cases, cases_gr1, cases_gr2), names_to="signal", values_to="value") %>%
  mutate(facet = dplyr::recode_factor(signal,
                                      cases = "(CA) Cases",
                                      cases_gr1 = "(CA) Case Growth Rate",
                                      cases_gr2 = "(CA) Case Growth Rate")) %>%
  ggplot(aes(time_value, value, colour=signal)) +
  facet_wrap(~ facet, ncol=1L, scales="free_y") +
  geom_line(na.rm=TRUE)
```

<!-- TODO add direction annotations derived from these growth rates? -->

::: notes
- Several methods and parameter settings for defining growth rates are provided
- E.g., gr1 here is using a relative change of counts in a small window, which is more heavily impacted by the negative blip around July 2021 than gr2.  We might try a different change rate calculation like gr2, or outlier removal.
:::

## `epiprocess::detect_outlr*`

```{r}
# vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
with_outlier_info =
  jhu_csse_daily_subset %>%
  select(geo_value, time_value, cases) %>%
  group_by(geo_value) %>%
  mutate(outlier_info = detect_outlr_rm(time_value, cases))
# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
# -------------------------------
# ---------- Plotting: ----------
# -------------------------------
outlier_facets =
  c("Points outside bands are marked as outliers",
    "Replacement values are available for simple outlier corrections") %>%
  {factor(., levels=.)} # (to avoid facet alphabetization)
with_outlier_info %>%
  unpack(outlier_info) %>%
  filter(geo_value == "ca") %>%
  mutate(facet = outlier_facets[[1L]]) %>%
  ggplot(aes(time_value, cases, ymin=lower, ymax=upper)) +
  geom_line() +
  geom_ribbon(colour = "red", linetype="dashed", fill = NA) +
  facet_wrap(~ facet, ncol=1L) +
  geom_line(data = function(df) df %>% mutate(facet = outlier_facets[[2L]]), linetype = "dashed") +
  geom_line(data = function(df) df %>% mutate(facet = outlier_facets[[2L]]), colour = "blue",
            mapping = aes(y = replacement))
```

::: notes
- Several methods and parameter settings for defining growth rates are provided
- Ensembling
- Correction
- This plot shows retrospective corrections for the time series, not real-time corrections; to see what the real-time calculations would have looked like, we'd use `epix_slide`, discussed later
:::

<!-- TODO point to / mention full vignettes for each topic? -->

<!-- TODO crediting Evan & others -->

## `epiprocess::epi_cor`

Kendall correlations across a limited (toy) set of `geo_value`s between deaths and cases 21 days prior, by `time_value`:
```{r}
# vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
cors =
  jhu_csse_daily_subset %>%
  epi_cor(death_rate_7d_av, case_rate_7d_av, dt2 = -21L,
          cor_by = "time_value", method="kendall")
# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
# -------------------------------
# ---------- Plotting: ----------
# -------------------------------
cor_facets =
  c("Kendall correlations between deaths & 21d-lagged cases, across geos, by time",
    "Death rates",
    "21d-lagged case rates") %>%
  {factor(., levels=.)}
cors %>%
  mutate(facet = cor_facets[[1L]]) %>%
  ggplot(aes(x = time_value, y = cor)) +
  geom_line(na.rm=TRUE) +
  geom_line(aes(y=death_rate_7d_av, colour=geo_value),
            jhu_csse_daily_subset %>% mutate(facet = cor_facets[[2L]])) +
  geom_line(aes(y=case_rate_7d_av, colour=geo_value),
            jhu_csse_daily_subset %>%
              group_by(geo_value) %>%
              mutate(case_rate_7d_av = lag(case_rate_7d_av, 21L)) %>%
              ungroup() %>%
              mutate(facet = cor_facets[[3L]]),
            na.rm=TRUE) +
  facet_wrap(~ facet, ncol=1L, scales="free_y") +
  scale_x_date(minor_breaks = "month", date_labels = "%b '%y") +
  labs(x = "Date", y = "Correlation")
```

::: notes
- Roughly, do weekly case rates 21 days ago seem helpful in determining whether one state will have higher weekly death rates than another, and does that usefulness vary across time?
- Since this is only using a few locations, extreme values are expected to be more common.
:::

## `epiprocess::epi_slide`

Optionally-grouped, rolling time window calculations:
```{r}
sum_of_k_else_na = function(x, k) {
  if (length(x) == k) sum(x) else vctrs::vec_cast(NA, x)
}
n_geos = nrow(distinct(jhu_csse_daily_subset, geo_value))
# vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
jhu_csse_daily_subset %>%
  select(geo_value, time_value, cases) %>%
  group_by(geo_value) %>%
  epi_slide(same_geo_7d_sum = sum_of_k_else_na(cases, 7L), n=7L) %>%
  ungroup() %>%
  epi_slide(cross_geo_7d_sum = sum_of_k_else_na(cases, 7L*n_geos), n=7L) %>%
# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  # -------------------------------
  # ---------- plotting: ----------
  # -------------------------------
  filter(geo_value == "fl") %>%
  pivot_longer(c(cases, same_geo_7d_sum, cross_geo_7d_sum), names_to="signal", values_to="value") %>%
  ggplot(aes(time_value, value, colour=signal)) +
  geom_line()
```

<!-- TODO list perceived use cases? -->
<!-- https://github.com/cmu-delphi/epiprocess/issues/256 -->


## `epiprocess::epi_archive`

Version history (and present) of an epi surveillance data set.
```{r}
archive_cases_dv_subset
archive_cases_dv_subset$DT
```

## Examining an `epi_archive`

```{r, echo=FALSE, message=FALSE, warning=FALSE}
x <- archive_cases_dv_subset
x_latest <- epix_as_of(x, max_version = x$versions_end)
versions = seq(as.Date("2020-06-01"), x$versions_end - 1, by = "1 month")
snapshots <- map_dfr(versions, function(v) {
  epix_as_of(x, max_version = v) %>% mutate(version = v)}) %>%
  bind_rows(x_latest %>% mutate(version = x$versions_end)) %>%
  mutate(latest = version == x$versions_end) %>%
  filter(geo_value %in% c("ca", "fl"))

ggplot(snapshots %>% filter(!latest),
            aes(x = time_value, y = percent_cli)) +
  geom_line(aes(color = factor(version))) +
  geom_vline(aes(color = factor(version), xintercept = version), lty = 2) +
  facet_wrap(~ geo_value, scales = "free_y", nrow = 1) +
  scale_x_date(minor_breaks = "month", date_labels = "%b %y") +
  labs(x = "Date", y = "% of doctor's visits with CLI") +
  theme(legend.position = "none") +
  geom_line(data = snapshots %>% filter(latest),
               aes(x = time_value, y = percent_cli),
               inherit.aes = FALSE, color = "black")
```

::: notes
* Easy to inspect revision behaviour
* Can use it for pseudo-prospective forecasts
* Compare to our procedure for the PNAS article &mdash; store every version as a `.csv` and load them individually
:::

## `epiprocess::epix_slide`

Version-aware counterpart to `epi_slide`.  Performs a time-windowed calculation using snapshot of data as of each of the requested `ref_time_values`.
```{r}
# vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
slide_result =
  archive_cases_dv_subset %>%
  epix_slide(~ tibble(
    dat = .x %>% list(),
    coefs = .x %>%
      complete(time_value = full_seq(time_value, 1L)) %>%
      lm(formula = case_rate_7d_av ~ lag(case_rate_7d_av, 7L) + lag(case_rate_7d_av, 14L) + 0) %>%
      coef() %>%
      list()
  ), n=90L, group_by=geo_value, ref_time_values = seq(as.Date("2020-06-01")+89L, as.Date("2021-11-30"), by="week")) %>%
  rename(as_of = time_value)
# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
```

## `epiprocess::epix_slide`

```{r}
slide_result
```

::: notes
- (Note that data latency cuts into the amount of data available in the window.  For this JHU-CSSE case data, it's only 1 day out of the 90 day window, but we must be careful with indexing.)
:::

## `epiprocess::epix_slide`

```{r}
# -------------------------------
# ---------- Plotting: ----------
# -------------------------------
slide_result_facets = c(
  "Coefficients by date of (pseudoprospective) fit",
  "Signal data by time_value"
) %>%
  {factor(., levels=.)}
slide_result %>%
  unnest_longer(slide_value_coefs, indices_to="feature", values_to="coefficient") %>%
  filter(geo_value == "ny") %>%
  mutate(facet = slide_result_facets[[1L]]) %>%
  ggplot() +
  facet_wrap(~ facet, ncol=1L, scales="free_y") +
  geom_line(
    aes(as_of, coefficient, linetype=feature)
  ) +
  geom_line(
    aes(time_value, case_rate_7d_av, colour=as_of, group=as_of),
    slide_result %>%
      # transmute(as_of = ordered(as_of), slide_value_dat) %>%
      transmute(as_of = as_of, slide_value_dat) %>%
      unnest(slide_value_dat) %>%
      filter(geo_value == "ny") %>%
      mutate(facet = slide_result_facets[[2L]])
  ) +
  guides(linetype = guide_legend(order=1L),
         colour = guide_legend(order=2L)) +
  xlab("as_of for coefficients / time_value for signals") +
  ylab("coefficient / (unlagged) value")
```

::: notes
- note that revisions and latency aren't very prominent in this toy data set,
but are in other disease forecasting targets and predictors
:::

<!-- TODO move `epidatr` material here and segue from above note? -->

## `epiprocess` overview

| Vectors         | `epi_df`s         |              `epi_archive`s |
|:---------------:|:-----------------:|----------------------------:|
|                 |                   |                             |
| `growth_rate`   | `epi_cor`         |                             |
| `detect_outlr*` |                   |                             |
|                 |                   |                             |
|                 |                   |                `epix_as_of` |
|                 |                   |                             |
|                 | `dplyr::*`        |                             |
|                 | `tsibble` interop |                             |
|                 |                   |                             |
|                 | `epi_slide`       |                `epix_slide` |
|                 |                   |                             |
|                 |                   | `epix_fill_through_version` |
|                 |                   |                `epix_merge` |
|                 |                   |                             |
|                 | toy data set      |                toy data set |


# TODO `{epidatr}`

# `{epipredict}`

<https://cmu-delphi.github.io/epipredict>

## TODO borrow Dan's slides / changelog
